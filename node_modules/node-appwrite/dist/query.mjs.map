{"version":3,"sources":["../src/query.ts"],"names":[],"mappings":"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","sourcesContent":["import JSONbigModule from 'json-bigint';\nconst JSONbig = JSONbigModule({ useNativeBigInt: true });\n\ntype QueryTypesSingle = string | number | bigint | boolean;\nexport type QueryTypesList = string[] | number[] | bigint[] | boolean[] | Query[] | any[];\nexport type QueryTypes = QueryTypesSingle | QueryTypesList;\ntype AttributesTypes = string | string[];\n\n/**\n * Helper class to generate query strings.\n */\nexport class Query {\n  method: string;\n  attribute: AttributesTypes | undefined;\n  values: QueryTypesList | undefined;\n\n  /**\n   * Constructor for Query class.\n   *\n   * @param {string} method\n   * @param {AttributesTypes} attribute\n   * @param {QueryTypes} values\n   */\n  constructor(\n    method: string,\n    attribute?: AttributesTypes,\n    values?: QueryTypes\n  ) {\n    this.method = method;\n    this.attribute = attribute;\n\n    if (values !== undefined) {\n      if (Array.isArray(values)) {\n        this.values = values;\n      } else {\n        this.values = [values] as QueryTypesList;\n      }\n    }\n  }\n\n  /**\n   * Convert the query object to a JSON string.\n   *\n   * @returns {string}\n   */\n  toString(): string {\n    return JSONbig.stringify({\n      method: this.method,\n      attribute: this.attribute,\n      values: this.values,\n    });\n  }\n\n  /**\n   * Filter resources where attribute is equal to value.\n   *\n   * @param {string} attribute\n   * @param {QueryTypes} value\n   * @returns {string}\n   */\n  static equal = (attribute: string, value: QueryTypes): string =>\n    new Query(\"equal\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute is not equal to value.\n   *\n   * @param {string} attribute\n   * @param {QueryTypes} value\n   * @returns {string}\n   */\n  static notEqual = (attribute: string, value: QueryTypes): string =>\n    new Query(\"notEqual\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute matches a regular expression pattern.\n   *\n   * @param {string} attribute The attribute to filter on.\n   * @param {string} pattern The regular expression pattern to match.\n   * @returns {string}\n   */\n  static regex = (attribute: string, pattern: string): string =>\n    new Query(\"regex\", attribute, pattern).toString();\n\n  /**\n   * Filter resources where attribute is less than value.\n   *\n   * @param {string} attribute\n   * @param {QueryTypes} value\n   * @returns {string}\n   */\n  static lessThan = (attribute: string, value: QueryTypes): string =>\n    new Query(\"lessThan\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute is less than or equal to value.\n   *\n   * @param {string} attribute\n   * @param {QueryTypes} value\n   * @returns {string}\n   */\n  static lessThanEqual = (attribute: string, value: QueryTypes): string =>\n    new Query(\"lessThanEqual\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute is greater than value.\n   *\n   * @param {string} attribute\n   * @param {QueryTypes} value\n   * @returns {string}\n   */\n  static greaterThan = (attribute: string, value: QueryTypes): string =>\n    new Query(\"greaterThan\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute is greater than or equal to value.\n   *\n   * @param {string} attribute\n   * @param {QueryTypes} value\n   * @returns {string}\n   */\n  static greaterThanEqual = (attribute: string, value: QueryTypes): string =>\n    new Query(\"greaterThanEqual\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute is null.\n   *\n   * @param {string} attribute\n   * @returns {string}\n   */\n  static isNull = (attribute: string): string =>\n    new Query(\"isNull\", attribute).toString();\n\n  /**\n   * Filter resources where attribute is not null.\n   *\n   * @param {string} attribute\n   * @returns {string}\n   */\n  static isNotNull = (attribute: string): string =>\n    new Query(\"isNotNull\", attribute).toString();\n\n  /**\n   * Filter resources where the specified attributes exist.\n   *\n   * @param {string[]} attributes The list of attributes that must exist.\n   * @returns {string}\n   */\n  static exists = (attributes: string[]): string =>\n    new Query(\"exists\", undefined, attributes).toString();\n\n  /**\n   * Filter resources where the specified attributes do not exist.\n   *\n   * @param {string[]} attributes The list of attributes that must not exist.\n   * @returns {string}\n   */\n  static notExists = (attributes: string[]): string =>\n    new Query(\"notExists\", undefined, attributes).toString();\n\n  /**\n   * Filter resources where attribute is between start and end (inclusive).\n   *\n   * @param {string} attribute\n   * @param {string | number | bigint} start\n   * @param {string | number | bigint} end\n   * @returns {string}\n   */\n  static between = (attribute: string, start: string | number | bigint, end: string | number | bigint): string =>\n    new Query(\"between\", attribute, [start, end] as QueryTypesList).toString();\n\n  /**\n   * Filter resources where attribute starts with value.\n   *\n   * @param {string} attribute\n   * @param {string} value\n   * @returns {string}\n   */\n  static startsWith = (attribute: string, value: string): string =>\n    new Query(\"startsWith\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute ends with value.\n   *\n   * @param {string} attribute\n   * @param {string} value\n   * @returns {string}\n   */\n  static endsWith = (attribute: string, value: string): string =>\n    new Query(\"endsWith\", attribute, value).toString();\n\n  /**\n   * Specify which attributes should be returned by the API call.\n   *\n   * @param {string[]} attributes\n   * @returns {string}\n   */\n  static select = (attributes: string[]): string =>\n    new Query(\"select\", undefined, attributes).toString();\n\n  /**\n   * Filter resources by searching attribute for value.\n   * A fulltext index on attribute is required for this query to work.\n   *\n   * @param {string} attribute\n   * @param {string} value\n   * @returns {string}\n   */\n  static search = (attribute: string, value: string): string =>\n    new Query(\"search\", attribute, value).toString();\n\n  /**\n   * Sort results by attribute descending.\n   *\n   * @param {string} attribute\n   * @returns {string}\n   */\n  static orderDesc = (attribute: string): string =>\n    new Query(\"orderDesc\", attribute).toString();\n\n  /**\n   * Sort results by attribute ascending.\n   *\n   * @param {string} attribute\n   * @returns {string}\n   */\n  static orderAsc = (attribute: string): string =>\n    new Query(\"orderAsc\", attribute).toString();\n\n  /**\n   * Sort results randomly.\n   *\n   * @returns {string}\n   */\n  static orderRandom = (): string =>\n    new Query(\"orderRandom\").toString();\n\n  /**\n   * Return results after documentId.\n   *\n   * @param {string} documentId\n   * @returns {string}\n   */\n  static cursorAfter = (documentId: string): string =>\n    new Query(\"cursorAfter\", undefined, documentId).toString();\n\n  /**\n   * Return results before documentId.\n   *\n   * @param {string} documentId\n   * @returns {string}\n   */\n  static cursorBefore = (documentId: string): string =>\n    new Query(\"cursorBefore\", undefined, documentId).toString();\n\n  /**\n   * Return only limit results.\n   *\n   * @param {number} limit\n   * @returns {string}\n   */\n  static limit = (limit: number): string =>\n    new Query(\"limit\", undefined, limit).toString();\n\n  /**\n   * Filter resources by skipping the first offset results.\n   *\n   * @param {number} offset\n   * @returns {string}\n   */\n  static offset = (offset: number): string =>\n    new Query(\"offset\", undefined, offset).toString();\n\n  /**\n   * Filter resources where attribute contains the specified value.\n   *\n   * @param {string} attribute\n   * @param {string | string[]} value\n   * @returns {string}\n   */\n  static contains = (attribute: string, value: string | any[]): string =>\n    new Query(\"contains\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute does not contain the specified value.\n   *\n   * @param {string} attribute\n   * @param {string | any[]} value\n   * @returns {string}\n   */\n  static notContains = (attribute: string, value: string | any[]): string =>\n    new Query(\"notContains\", attribute, value).toString();\n\n  /**\n   * Filter resources by searching attribute for value (inverse of search).\n   * A fulltext index on attribute is required for this query to work.\n   *\n   * @param {string} attribute\n   * @param {string} value\n   * @returns {string}\n   */\n  static notSearch = (attribute: string, value: string): string =>\n    new Query(\"notSearch\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute is not between start and end (exclusive).\n   *\n   * @param {string} attribute\n   * @param {string | number | bigint} start\n   * @param {string | number | bigint} end\n   * @returns {string}\n   */\n  static notBetween = (attribute: string, start: string | number | bigint, end: string | number | bigint): string =>\n    new Query(\"notBetween\", attribute, [start, end] as QueryTypesList).toString();\n\n  /**\n   * Filter resources where attribute does not start with value.\n   *\n   * @param {string} attribute\n   * @param {string} value\n   * @returns {string}\n   */\n  static notStartsWith = (attribute: string, value: string): string =>\n    new Query(\"notStartsWith\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute does not end with value.\n   *\n   * @param {string} attribute\n   * @param {string} value\n   * @returns {string}\n   */\n  static notEndsWith = (attribute: string, value: string): string =>\n    new Query(\"notEndsWith\", attribute, value).toString();\n\n  /**\n   * Filter resources where document was created before date.\n   *\n   * @param {string} value\n   * @returns {string}\n   */\n  static createdBefore = (value: string): string =>\n    Query.lessThan(\"$createdAt\", value);\n\n  /**\n   * Filter resources where document was created after date.\n   *\n   * @param {string} value\n   * @returns {string}\n   */\n  static createdAfter = (value: string): string =>\n    Query.greaterThan(\"$createdAt\", value);\n\n  /**\n   * Filter resources where document was created between dates.\n   *\n   * @param {string} start\n   * @param {string} end\n   * @returns {string}\n   */\n  static createdBetween = (start: string, end: string): string =>\n    Query.between(\"$createdAt\", start, end);\n\n  /**\n   * Filter resources where document was updated before date.\n   *\n   * @param {string} value\n   * @returns {string}\n   */\n  static updatedBefore = (value: string): string =>\n    Query.lessThan(\"$updatedAt\", value);\n\n  /**\n   * Filter resources where document was updated after date.\n   *\n   * @param {string} value\n   * @returns {string}\n   */\n  static updatedAfter = (value: string): string =>\n    Query.greaterThan(\"$updatedAt\", value);\n\n  /**\n   * Filter resources where document was updated between dates.\n   *\n   * @param {string} start\n   * @param {string} end\n   * @returns {string}\n   */\n  static updatedBetween = (start: string, end: string): string =>\n    Query.between(\"$updatedAt\", start, end);\n\n  /**\n   * Combine multiple queries using logical OR operator.\n   *\n   * @param {string[]} queries\n   * @returns {string}\n   */\n  static or = (queries: string[]) =>\n    new Query(\"or\", undefined, queries.map((query) => JSONbig.parse(query))).toString();\n\n  /**\n   * Combine multiple queries using logical AND operator.\n   *\n   * @param {string[]} queries\n   * @returns {string}\n   */\n  static and = (queries: string[]) =>\n    new Query(\"and\", undefined, queries.map((query) => JSONbig.parse(query))).toString();\n\n  /**\n   * Filter array elements where at least one element matches all the specified queries.\n   *\n   * @param {string} attribute The attribute containing the array to filter on.\n   * @param {string[]} queries The list of query strings to match against array elements.\n   * @returns {string}\n   */\n  static elemMatch = (attribute: string, queries: string[]): string =>\n    new Query(\n      \"elemMatch\",\n      attribute,\n      queries.map((query) => JSONbig.parse(query))\n    ).toString();\n\n  /**\n   * Filter resources where attribute is at a specific distance from the given coordinates.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @param {number} distance\n   * @param {boolean} meters\n   * @returns {string}\n   */\n  static distanceEqual = (attribute: string, values: any[], distance: number, meters: boolean = true): string =>\n    new Query(\"distanceEqual\", attribute, [[values, distance, meters]] as QueryTypesList).toString();\n\n  /**\n   * Filter resources where attribute is not at a specific distance from the given coordinates.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @param {number} distance\n   * @param {boolean} meters\n   * @returns {string}\n   */\n  static distanceNotEqual = (attribute: string, values: any[], distance: number, meters: boolean = true): string =>\n    new Query(\"distanceNotEqual\", attribute, [[values, distance, meters]] as QueryTypesList).toString();\n\n  /**\n   * Filter resources where attribute is at a distance greater than the specified value from the given coordinates.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @param {number} distance\n   * @param {boolean} meters\n   * @returns {string}\n   */\n  static distanceGreaterThan = (attribute: string, values: any[], distance: number, meters: boolean = true): string =>\n    new Query(\"distanceGreaterThan\", attribute, [[values, distance, meters]] as QueryTypesList).toString();\n\n  /**\n   * Filter resources where attribute is at a distance less than the specified value from the given coordinates.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @param {number} distance\n   * @param {boolean} meters\n   * @returns {string}\n   */\n  static distanceLessThan = (attribute: string, values: any[], distance: number, meters: boolean = true): string =>\n    new Query(\"distanceLessThan\", attribute, [[values, distance, meters]] as QueryTypesList).toString();\n\n  /**\n   * Filter resources where attribute intersects with the given geometry.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @returns {string}\n   */\n  static intersects = (attribute: string, values: any[]): string =>\n    new Query(\"intersects\", attribute, [values]).toString();\n\n  /**\n   * Filter resources where attribute does not intersect with the given geometry.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @returns {string}\n   */\n  static notIntersects = (attribute: string, values: any[]): string =>\n    new Query(\"notIntersects\", attribute, [values]).toString();\n\n  /**\n   * Filter resources where attribute crosses the given geometry.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @returns {string}\n   */\n  static crosses = (attribute: string, values: any[]): string =>\n    new Query(\"crosses\", attribute, [values]).toString();\n\n  /**\n   * Filter resources where attribute does not cross the given geometry.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @returns {string}\n   */\n  static notCrosses = (attribute: string, values: any[]): string =>\n    new Query(\"notCrosses\", attribute, [values]).toString();\n\n  /**\n   * Filter resources where attribute overlaps with the given geometry.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @returns {string}\n   */\n  static overlaps = (attribute: string, values: any[]): string =>\n    new Query(\"overlaps\", attribute, [values]).toString();\n\n  /**\n   * Filter resources where attribute does not overlap with the given geometry.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @returns {string}\n   */\n  static notOverlaps = (attribute: string, values: any[]): string =>\n    new Query(\"notOverlaps\", attribute, [values]).toString();\n\n  /**\n   * Filter resources where attribute touches the given geometry.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @returns {string}\n   */\n  static touches = (attribute: string, values: any[]): string =>\n    new Query(\"touches\", attribute, [values]).toString();\n\n  /**\n   * Filter resources where attribute does not touch the given geometry.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @returns {string}\n   */\n  static notTouches = (attribute: string, values: any[]): string =>\n    new Query(\"notTouches\", attribute, [values]).toString();\n}\n"]}