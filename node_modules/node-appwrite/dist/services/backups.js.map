{"version":3,"sources":["../../src/services/backups.ts"],"names":[],"mappings":"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","sourcesContent":["import { AppwriteException, Client, type Payload, UploadProgress } from '../client';\nimport type { Models } from '../models';\n\nimport { BackupServices } from '../enums/backup-services';\n\nexport class Backups {\n    client: Client;\n\n    constructor(client: Client) {\n        this.client = client;\n    }\n\n    /**\n     * List all archives for a project.\n     *\n     * @param {string[]} params.queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupArchiveList>}\n     */\n    listArchives(params?: { queries?: string[] }): Promise<Models.BackupArchiveList>;\n    /**\n     * List all archives for a project.\n     *\n     * @param {string[]} queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupArchiveList>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    listArchives(queries?: string[]): Promise<Models.BackupArchiveList>;\n    listArchives(\n        paramsOrFirst?: { queries?: string[] } | string[]    \n    ): Promise<Models.BackupArchiveList> {\n        let params: { queries?: string[] };\n        \n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { queries?: string[] };\n        } else {\n            params = {\n                queries: paramsOrFirst as string[]            \n            };\n        }\n        \n        const queries = params.queries;\n\n\n        const apiPath = '/backups/archives';\n        const payload: Payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new archive asynchronously for a project.\n     *\n     * @param {BackupServices[]} params.services - Array of services to backup\n     * @param {string} params.resourceId - Resource ID. When set, only this single resource will be backed up.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupArchive>}\n     */\n    createArchive(params: { services: BackupServices[], resourceId?: string }): Promise<Models.BackupArchive>;\n    /**\n     * Create a new archive asynchronously for a project.\n     *\n     * @param {BackupServices[]} services - Array of services to backup\n     * @param {string} resourceId - Resource ID. When set, only this single resource will be backed up.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupArchive>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createArchive(services: BackupServices[], resourceId?: string): Promise<Models.BackupArchive>;\n    createArchive(\n        paramsOrFirst: { services: BackupServices[], resourceId?: string } | BackupServices[],\n        ...rest: [(string)?]    \n    ): Promise<Models.BackupArchive> {\n        let params: { services: BackupServices[], resourceId?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('services' in paramsOrFirst || 'resourceId' in paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { services: BackupServices[], resourceId?: string };\n        } else {\n            params = {\n                services: paramsOrFirst as BackupServices[],\n                resourceId: rest[0] as string            \n            };\n        }\n        \n        const services = params.services;\n        const resourceId = params.resourceId;\n\n        if (typeof services === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"services\"');\n        }\n\n        const apiPath = '/backups/archives';\n        const payload: Payload = {};\n        if (typeof services !== 'undefined') {\n            payload['services'] = services;\n        }\n        if (typeof resourceId !== 'undefined') {\n            payload['resourceId'] = resourceId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Get a backup archive using it's ID.\n     *\n     * @param {string} params.archiveId - Archive ID. Choose a custom ID`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupArchive>}\n     */\n    getArchive(params: { archiveId: string }): Promise<Models.BackupArchive>;\n    /**\n     * Get a backup archive using it's ID.\n     *\n     * @param {string} archiveId - Archive ID. Choose a custom ID`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupArchive>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    getArchive(archiveId: string): Promise<Models.BackupArchive>;\n    getArchive(\n        paramsOrFirst: { archiveId: string } | string    \n    ): Promise<Models.BackupArchive> {\n        let params: { archiveId: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { archiveId: string };\n        } else {\n            params = {\n                archiveId: paramsOrFirst as string            \n            };\n        }\n        \n        const archiveId = params.archiveId;\n\n        if (typeof archiveId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"archiveId\"');\n        }\n\n        const apiPath = '/backups/archives/{archiveId}'.replace('{archiveId}', archiveId);\n        const payload: Payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Delete an existing archive for a project.\n     *\n     * @param {string} params.archiveId - Policy ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     */\n    deleteArchive(params: { archiveId: string }): Promise<{}>;\n    /**\n     * Delete an existing archive for a project.\n     *\n     * @param {string} archiveId - Policy ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    deleteArchive(archiveId: string): Promise<{}>;\n    deleteArchive(\n        paramsOrFirst: { archiveId: string } | string    \n    ): Promise<{}> {\n        let params: { archiveId: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { archiveId: string };\n        } else {\n            params = {\n                archiveId: paramsOrFirst as string            \n            };\n        }\n        \n        const archiveId = params.archiveId;\n\n        if (typeof archiveId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"archiveId\"');\n        }\n\n        const apiPath = '/backups/archives/{archiveId}'.replace('{archiveId}', archiveId);\n        const payload: Payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'delete',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * List all policies for a project.\n     *\n     * @param {string[]} params.queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupPolicyList>}\n     */\n    listPolicies(params?: { queries?: string[] }): Promise<Models.BackupPolicyList>;\n    /**\n     * List all policies for a project.\n     *\n     * @param {string[]} queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupPolicyList>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    listPolicies(queries?: string[]): Promise<Models.BackupPolicyList>;\n    listPolicies(\n        paramsOrFirst?: { queries?: string[] } | string[]    \n    ): Promise<Models.BackupPolicyList> {\n        let params: { queries?: string[] };\n        \n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { queries?: string[] };\n        } else {\n            params = {\n                queries: paramsOrFirst as string[]            \n            };\n        }\n        \n        const queries = params.queries;\n\n\n        const apiPath = '/backups/policies';\n        const payload: Payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new backup policy.\n     *\n     * @param {string} params.policyId - Policy ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {BackupServices[]} params.services - Array of services to backup\n     * @param {number} params.retention - Days to keep backups before deletion\n     * @param {string} params.schedule - Schedule CRON syntax.\n     * @param {string} params.name - Policy name. Max length: 128 chars.\n     * @param {string} params.resourceId - Resource ID. When set, only this single resource will be backed up.\n     * @param {boolean} params.enabled - Is policy enabled? When set to 'disabled', no backups will be taken\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupPolicy>}\n     */\n    createPolicy(params: { policyId: string, services: BackupServices[], retention: number, schedule: string, name?: string, resourceId?: string, enabled?: boolean }): Promise<Models.BackupPolicy>;\n    /**\n     * Create a new backup policy.\n     *\n     * @param {string} policyId - Policy ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {BackupServices[]} services - Array of services to backup\n     * @param {number} retention - Days to keep backups before deletion\n     * @param {string} schedule - Schedule CRON syntax.\n     * @param {string} name - Policy name. Max length: 128 chars.\n     * @param {string} resourceId - Resource ID. When set, only this single resource will be backed up.\n     * @param {boolean} enabled - Is policy enabled? When set to 'disabled', no backups will be taken\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupPolicy>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createPolicy(policyId: string, services: BackupServices[], retention: number, schedule: string, name?: string, resourceId?: string, enabled?: boolean): Promise<Models.BackupPolicy>;\n    createPolicy(\n        paramsOrFirst: { policyId: string, services: BackupServices[], retention: number, schedule: string, name?: string, resourceId?: string, enabled?: boolean } | string,\n        ...rest: [(BackupServices[])?, (number)?, (string)?, (string)?, (string)?, (boolean)?]    \n    ): Promise<Models.BackupPolicy> {\n        let params: { policyId: string, services: BackupServices[], retention: number, schedule: string, name?: string, resourceId?: string, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { policyId: string, services: BackupServices[], retention: number, schedule: string, name?: string, resourceId?: string, enabled?: boolean };\n        } else {\n            params = {\n                policyId: paramsOrFirst as string,\n                services: rest[0] as BackupServices[],\n                retention: rest[1] as number,\n                schedule: rest[2] as string,\n                name: rest[3] as string,\n                resourceId: rest[4] as string,\n                enabled: rest[5] as boolean            \n            };\n        }\n        \n        const policyId = params.policyId;\n        const services = params.services;\n        const retention = params.retention;\n        const schedule = params.schedule;\n        const name = params.name;\n        const resourceId = params.resourceId;\n        const enabled = params.enabled;\n\n        if (typeof policyId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"policyId\"');\n        }\n        if (typeof services === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"services\"');\n        }\n        if (typeof retention === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"retention\"');\n        }\n        if (typeof schedule === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"schedule\"');\n        }\n\n        const apiPath = '/backups/policies';\n        const payload: Payload = {};\n        if (typeof policyId !== 'undefined') {\n            payload['policyId'] = policyId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof services !== 'undefined') {\n            payload['services'] = services;\n        }\n        if (typeof resourceId !== 'undefined') {\n            payload['resourceId'] = resourceId;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        if (typeof retention !== 'undefined') {\n            payload['retention'] = retention;\n        }\n        if (typeof schedule !== 'undefined') {\n            payload['schedule'] = schedule;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Get a backup policy using it's ID.\n     *\n     * @param {string} params.policyId - Policy ID. Choose a custom ID`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupPolicy>}\n     */\n    getPolicy(params: { policyId: string }): Promise<Models.BackupPolicy>;\n    /**\n     * Get a backup policy using it's ID.\n     *\n     * @param {string} policyId - Policy ID. Choose a custom ID`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupPolicy>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    getPolicy(policyId: string): Promise<Models.BackupPolicy>;\n    getPolicy(\n        paramsOrFirst: { policyId: string } | string    \n    ): Promise<Models.BackupPolicy> {\n        let params: { policyId: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { policyId: string };\n        } else {\n            params = {\n                policyId: paramsOrFirst as string            \n            };\n        }\n        \n        const policyId = params.policyId;\n\n        if (typeof policyId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"policyId\"');\n        }\n\n        const apiPath = '/backups/policies/{policyId}'.replace('{policyId}', policyId);\n        const payload: Payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update an existing policy using it's ID.\n     *\n     * @param {string} params.policyId - Policy ID. Choose a custom ID`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.name - Policy name. Max length: 128 chars.\n     * @param {number} params.retention - Days to keep backups before deletion\n     * @param {string} params.schedule - Cron expression\n     * @param {boolean} params.enabled - Is Backup enabled? When set to 'disabled', No backup will be taken\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupPolicy>}\n     */\n    updatePolicy(params: { policyId: string, name?: string, retention?: number, schedule?: string, enabled?: boolean }): Promise<Models.BackupPolicy>;\n    /**\n     * Update an existing policy using it's ID.\n     *\n     * @param {string} policyId - Policy ID. Choose a custom ID`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} name - Policy name. Max length: 128 chars.\n     * @param {number} retention - Days to keep backups before deletion\n     * @param {string} schedule - Cron expression\n     * @param {boolean} enabled - Is Backup enabled? When set to 'disabled', No backup will be taken\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupPolicy>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updatePolicy(policyId: string, name?: string, retention?: number, schedule?: string, enabled?: boolean): Promise<Models.BackupPolicy>;\n    updatePolicy(\n        paramsOrFirst: { policyId: string, name?: string, retention?: number, schedule?: string, enabled?: boolean } | string,\n        ...rest: [(string)?, (number)?, (string)?, (boolean)?]    \n    ): Promise<Models.BackupPolicy> {\n        let params: { policyId: string, name?: string, retention?: number, schedule?: string, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { policyId: string, name?: string, retention?: number, schedule?: string, enabled?: boolean };\n        } else {\n            params = {\n                policyId: paramsOrFirst as string,\n                name: rest[0] as string,\n                retention: rest[1] as number,\n                schedule: rest[2] as string,\n                enabled: rest[3] as boolean            \n            };\n        }\n        \n        const policyId = params.policyId;\n        const name = params.name;\n        const retention = params.retention;\n        const schedule = params.schedule;\n        const enabled = params.enabled;\n\n        if (typeof policyId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"policyId\"');\n        }\n\n        const apiPath = '/backups/policies/{policyId}'.replace('{policyId}', policyId);\n        const payload: Payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof retention !== 'undefined') {\n            payload['retention'] = retention;\n        }\n        if (typeof schedule !== 'undefined') {\n            payload['schedule'] = schedule;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Delete a policy using it's ID.\n     *\n     * @param {string} params.policyId - Policy ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     */\n    deletePolicy(params: { policyId: string }): Promise<{}>;\n    /**\n     * Delete a policy using it's ID.\n     *\n     * @param {string} policyId - Policy ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    deletePolicy(policyId: string): Promise<{}>;\n    deletePolicy(\n        paramsOrFirst: { policyId: string } | string    \n    ): Promise<{}> {\n        let params: { policyId: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { policyId: string };\n        } else {\n            params = {\n                policyId: paramsOrFirst as string            \n            };\n        }\n        \n        const policyId = params.policyId;\n\n        if (typeof policyId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"policyId\"');\n        }\n\n        const apiPath = '/backups/policies/{policyId}'.replace('{policyId}', policyId);\n        const payload: Payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'delete',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create and trigger a new restoration for a backup on a project.\n     *\n     * @param {string} params.archiveId - Backup archive ID to restore\n     * @param {BackupServices[]} params.services - Array of services to restore\n     * @param {string} params.newResourceId - Unique Id. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.newResourceName - Database name. Max length: 128 chars.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupRestoration>}\n     */\n    createRestoration(params: { archiveId: string, services: BackupServices[], newResourceId?: string, newResourceName?: string }): Promise<Models.BackupRestoration>;\n    /**\n     * Create and trigger a new restoration for a backup on a project.\n     *\n     * @param {string} archiveId - Backup archive ID to restore\n     * @param {BackupServices[]} services - Array of services to restore\n     * @param {string} newResourceId - Unique Id. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} newResourceName - Database name. Max length: 128 chars.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupRestoration>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createRestoration(archiveId: string, services: BackupServices[], newResourceId?: string, newResourceName?: string): Promise<Models.BackupRestoration>;\n    createRestoration(\n        paramsOrFirst: { archiveId: string, services: BackupServices[], newResourceId?: string, newResourceName?: string } | string,\n        ...rest: [(BackupServices[])?, (string)?, (string)?]    \n    ): Promise<Models.BackupRestoration> {\n        let params: { archiveId: string, services: BackupServices[], newResourceId?: string, newResourceName?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { archiveId: string, services: BackupServices[], newResourceId?: string, newResourceName?: string };\n        } else {\n            params = {\n                archiveId: paramsOrFirst as string,\n                services: rest[0] as BackupServices[],\n                newResourceId: rest[1] as string,\n                newResourceName: rest[2] as string            \n            };\n        }\n        \n        const archiveId = params.archiveId;\n        const services = params.services;\n        const newResourceId = params.newResourceId;\n        const newResourceName = params.newResourceName;\n\n        if (typeof archiveId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"archiveId\"');\n        }\n        if (typeof services === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"services\"');\n        }\n\n        const apiPath = '/backups/restoration';\n        const payload: Payload = {};\n        if (typeof archiveId !== 'undefined') {\n            payload['archiveId'] = archiveId;\n        }\n        if (typeof services !== 'undefined') {\n            payload['services'] = services;\n        }\n        if (typeof newResourceId !== 'undefined') {\n            payload['newResourceId'] = newResourceId;\n        }\n        if (typeof newResourceName !== 'undefined') {\n            payload['newResourceName'] = newResourceName;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * List all backup restorations for a project.\n     *\n     * @param {string[]} params.queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupRestorationList>}\n     */\n    listRestorations(params?: { queries?: string[] }): Promise<Models.BackupRestorationList>;\n    /**\n     * List all backup restorations for a project.\n     *\n     * @param {string[]} queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupRestorationList>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    listRestorations(queries?: string[]): Promise<Models.BackupRestorationList>;\n    listRestorations(\n        paramsOrFirst?: { queries?: string[] } | string[]    \n    ): Promise<Models.BackupRestorationList> {\n        let params: { queries?: string[] };\n        \n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { queries?: string[] };\n        } else {\n            params = {\n                queries: paramsOrFirst as string[]            \n            };\n        }\n        \n        const queries = params.queries;\n\n\n        const apiPath = '/backups/restorations';\n        const payload: Payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Get the current status of a backup restoration.\n     *\n     * @param {string} params.restorationId - Restoration ID. Choose a custom ID`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupRestoration>}\n     */\n    getRestoration(params: { restorationId: string }): Promise<Models.BackupRestoration>;\n    /**\n     * Get the current status of a backup restoration.\n     *\n     * @param {string} restorationId - Restoration ID. Choose a custom ID`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.BackupRestoration>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    getRestoration(restorationId: string): Promise<Models.BackupRestoration>;\n    getRestoration(\n        paramsOrFirst: { restorationId: string } | string    \n    ): Promise<Models.BackupRestoration> {\n        let params: { restorationId: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { restorationId: string };\n        } else {\n            params = {\n                restorationId: paramsOrFirst as string            \n            };\n        }\n        \n        const restorationId = params.restorationId;\n\n        if (typeof restorationId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"restorationId\"');\n        }\n\n        const apiPath = '/backups/restorations/{restorationId}'.replace('{restorationId}', restorationId);\n        const payload: Payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n}\n"]}